import { ForbiddenException, Inject, Injectable } from '@nestjs/common';
import { CreateUserDto } from '../../adapter/dto/create-user.dto';
import { UpdateUserDto } from '../../adapter/dto/update-user.dto';
import { UserServiceInterface } from '../port/in/user.service.interface';
import { UserRepositoryAWS } from '../../adapter/out/persistence/user.repository.AWS';
import { User, UserStatus, UserType } from '../../domain/user.domain';
import { SearchUserDto } from '../../adapter/dto/PageRequest.dto';
import { Page } from '../../adapter/dto/page';
import { Web3LoginClient } from '../../adapter/out/client/web3Login.client';

@Injectable()
export class UserService implements UserServiceInterface {
  constructor(
    @Inject(UserRepositoryAWS)
    private readonly userRepository: UserRepositoryAWS,
    @Inject(Web3LoginClient)
    private readonly web3LoginClient: Web3LoginClient,
  ) {}

  async changeUserStatus(updateUserDto: UpdateUserDto) {
    const user = await this.userRepository.findOneByEmail(updateUserDto.email);
    if (!user) {
      throw new ForbiddenException('User does not exist');
    }
    const UserFilteringTarget = Object.keys(UserType).filter((value) => value !== UserType.SUPERADMIN);
    if (!Object.values(UserFilteringTarget).includes(updateUserDto.userType)) {
      throw new ForbiddenException('Requested User type is not allowed. only allowed [USER, ADMIN]');
    }

    const UserStatusTarget = Object.keys(UserStatus);
    if (!Object.values(UserStatusTarget).includes(updateUserDto.status)) {
      throw new ForbiddenException(
        'Requested User status is not allowed. only allowed [ACTIVE, INACTIVE, PENDING, BLOCKED]',
      );
    }

    Object.assign(user, updateUserDto);
    const resultInfo = await this.userRepository.update(user);
    if (resultInfo.affected === 0) {
      throw new ForbiddenException('User update failed');
    }
    const changedUser = await this.userRepository.findOneByEmail(updateUserDto.email);
    return {
      message: 'User status changed successfully',
      email: changedUser.email,
      userType: changedUser.userType,
      status: changedUser.status,
    };
  }

  async create(createUserDto: CreateUserDto): Promise<User> {
    const user = new User(
      'it should be auto generated by Entity',
      createUserDto.username,
      createUserDto.email,
      createUserDto.password,
      createUserDto.refreshToken,
      createUserDto.accessToken,
      UserType.USER,
      UserStatus.ACTIVE,
    );
    return this.userRepository.save(user);
  }

  async findAllWithoutSuperadmin(page: SearchUserDto): Promise<Page<User>> {
    const totalCount = await this.userRepository.countWithoutSuperAdmin();
    const users = await this.userRepository.findAllByPage(page.getLimit(), page.getOffset());
    const filteredUsers = users.filter((user) => user.isExceptedSuperAdmin());
    return new Page(totalCount, +page.pageNo, +page.pageSize, filteredUsers);
  }

  async findAllOnlyAdmin() {
    return (await this.userRepository.findAll()).filter((user) => user.isAdmin());
  }

  async findById(uuid: string): Promise<User> {
    return this.userRepository.findOneByUUID(uuid);
  }

  async findOneByEmail(email: string): Promise<User> {
    return this.userRepository.findOneByEmail(email);
  }

  async update(uuid, updateUserDto: UpdateUserDto) {
    const user: User = await this.userRepository.findOneByUUID(uuid);
    if (!user) {
      throw new ForbiddenException('User does not exist');
    }

    Object.assign(user, updateUserDto);
    const updateResult = await this.userRepository.update(user);
    console.log(updateResult);
    if (updateResult.affected === 0) {
      throw new ForbiddenException('User update failed');
    }
    console.log(updateResult);
  }

  async remove(uuid: string) {
    const user = await this.userRepository.findOneByUUID(uuid);
    await this.userRepository.delete(user);
  }

  async claimReward(uuid: string, address: string, rewardType: string, reward: number) {
    const user = await this.userRepository.findOneByUUID(uuid);
    const userWalletAddress = user.getWalletAddress();

    if (!userWalletAddress.includes(address)) {
      throw new ForbiddenException('User does not have this wallet address');
    }

    //보상잔고 수정 요청
    await this.changeUserReward(uuid, rewardType, reward);

    //보상인출 요청
    await this.web3LoginClient.requestClaim(address, rewardType, reward);
  }

  async changeUserReward(uuid: string, rewardType: string, reward: number) {
    const user = await this.userRepository.findOneByUUID(uuid);
    if (reward > 0) {
      user.payReward(rewardType, reward);
    } else {
      user.deductReward(rewardType, reward);
    }
    await this.userRepository.update(user);
  }
}
